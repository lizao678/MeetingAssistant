<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å½•éŸ³åŠŸèƒ½åŸå‹éªŒè¯</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .recording-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .controls {
            margin: 10px 0;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .record-btn {
            background: #ff4d4f;
            color: white;
        }

        .stop-btn {
            background: #52c41a;
            color: white;
        }

        .play-btn {
            background: #1890ff;
            color: white;
        }

        .recordings-list {
            margin-top: 20px;
        }

        .recording-item {
            padding: 10px;
            border: 1px solid #eee;
            margin: 5px 0;
            border-radius: 4px;
        }

        .status {
            margin: 10px 0;
            font-weight: bold;
        }

        .duration {
            color: #666;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¤ å½•éŸ³åŠŸèƒ½åŸå‹éªŒè¯</h1>

        <!-- å½•éŸ³æ§åˆ¶åŒº -->
        <div class="recording-section">
            <h3>å½•éŸ³æ§åˆ¶</h3>
            <div class="controls">
                <button id="startRecord" class="record-btn">å¼€å§‹å½•éŸ³</button>
                <button id="stopRecord" class="stop-btn" disabled>åœæ­¢å½•éŸ³</button>
                <button id="playLast" class="play-btn" disabled>æ’­æ”¾æœ€æ–°å½•éŸ³</button>
            </div>
            <div id="status" class="status">å‡†å¤‡å°±ç»ª</div>
            <div id="duration" class="duration">æ—¶é•¿: 00:00</div>
        </div>

        <!-- å½•éŸ³åˆ—è¡¨ -->
        <div class="recording-section">
            <h3>å½•éŸ³å†å²</h3>
            <div id="recordingsList" class="recordings-list">
                <p>æš‚æ— å½•éŸ³è®°å½•</p>
            </div>
        </div>
    </div>

    <script>
        class RecordingManager {
            constructor() {
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.recordings = JSON.parse(localStorage.getItem('recordings') || '[]');
                this.isRecording = false;
                this.startTime = null;
                this.durationTimer = null;

                this.initElements();
                this.bindEvents();
                this.renderRecordings();
            }

            initElements() {
                this.startBtn = document.getElementById('startRecord');
                this.stopBtn = document.getElementById('stopRecord');
                this.playBtn = document.getElementById('playLast');
                this.status = document.getElementById('status');
                this.duration = document.getElementById('duration');
                this.recordingsList = document.getElementById('recordingsList');
            }

            bindEvents() {
                this.startBtn.addEventListener('click', () => this.startRecording());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
                this.playBtn.addEventListener('click', () => this.playLastRecording());
            }

            async startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 16000
                        }
                    });

                    this.mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });

                    this.audioChunks = [];
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        this.saveRecording();
                        stream.getTracks().forEach(track => track.stop());
                    };

                    this.mediaRecorder.start(1000); // æ¯ç§’æ”¶é›†ä¸€æ¬¡æ•°æ®
                    this.isRecording = true;
                    this.startTime = Date.now();

                    this.updateUI();
                    this.startDurationTimer();

                } catch (error) {
                    console.error('å½•éŸ³å¯åŠ¨å¤±è´¥:', error);
                    this.status.textContent = 'å½•éŸ³å¯åŠ¨å¤±è´¥: ' + error.message;
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    this.stopDurationTimer();
                    this.updateUI();
                }
            }

            saveRecording() {
                const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm;codecs=opus' });
                const audioUrl = URL.createObjectURL(audioBlob);
                const duration = Date.now() - this.startTime;

                const recording = {
                    id: Date.now(),
                    url: audioUrl,
                    blob: audioBlob,
                    duration: duration,
                    timestamp: new Date().toLocaleString('zh-CN'),
                    size: this.formatFileSize(audioBlob.size)
                };

                this.recordings.unshift(recording);
                this.saveToStorage();
                this.renderRecordings();

                this.status.textContent = `å½•éŸ³å·²ä¿å­˜ (${this.formatDuration(duration)})`;
                this.playBtn.disabled = false;
            }

            playLastRecording() {
                if (this.recordings.length > 0) {
                    const audio = new Audio(this.recordings[0].url);
                    audio.play();
                    this.status.textContent = 'æ­£åœ¨æ’­æ”¾æœ€æ–°å½•éŸ³...';

                    audio.onended = () => {
                        this.status.textContent = 'æ’­æ”¾å®Œæˆ';
                    };
                }
            }

            renderRecordings() {
                if (this.recordings.length === 0) {
                    this.recordingsList.innerHTML = '<p>æš‚æ— å½•éŸ³è®°å½•</p>';
                    return;
                }

                const html = this.recordings.map(recording => `
                    <div class="recording-item">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>å½•éŸ³ #${recording.id}</strong>
                                <div class="duration">æ—¶é•¿: ${this.formatDuration(recording.duration)} | å¤§å°: ${recording.size}</div>
                                <div style="color: #999; font-size: 12px;">${recording.timestamp}</div>
                            </div>
                            <div>
                                <button onclick="recordingManager.playRecording('${recording.url}')" class="play-btn">æ’­æ”¾</button>
                                <button onclick="recordingManager.downloadRecording(${recording.id})" class="play-btn">ä¸‹è½½</button>
                                <button onclick="recordingManager.deleteRecording(${recording.id})" style="background: #ff4d4f; color: white;">åˆ é™¤</button>
                            </div>
                        </div>
                    </div>
                `).join('');

                this.recordingsList.innerHTML = html;
            }

            playRecording(url) {
                const audio = new Audio(url);
                audio.play();
                this.status.textContent = 'æ­£åœ¨æ’­æ”¾å½•éŸ³...';
                audio.onended = () => {
                    this.status.textContent = 'æ’­æ”¾å®Œæˆ';
                };
            }

            downloadRecording(id) {
                const recording = this.recordings.find(r => r.id === id);
                if (recording) {
                    const a = document.createElement('a');
                    a.href = recording.url;
                    a.download = `recording_${recording.id}.webm`;
                    a.click();
                }
            }

            deleteRecording(id) {
                if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå½•éŸ³å—ï¼Ÿ')) {
                    this.recordings = this.recordings.filter(r => r.id !== id);
                    this.saveToStorage();
                    this.renderRecordings();
                    this.status.textContent = 'å½•éŸ³å·²åˆ é™¤';
                }
            }

            updateUI() {
                this.startBtn.disabled = this.isRecording;
                this.stopBtn.disabled = !this.isRecording;

                if (this.isRecording) {
                    this.status.textContent = 'å½•éŸ³ä¸­...';
                } else {
                    this.status.textContent = 'å½•éŸ³å·²åœæ­¢';
                }
            }

            startDurationTimer() {
                this.durationTimer = setInterval(() => {
                    if (this.isRecording && this.startTime) {
                        const elapsed = Date.now() - this.startTime;
                        this.duration.textContent = `æ—¶é•¿: ${this.formatDuration(elapsed)}`;
                    }
                }, 1000);
            }

            stopDurationTimer() {
                if (this.durationTimer) {
                    clearInterval(this.durationTimer);
                    this.durationTimer = null;
                }
            }

            formatDuration(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            saveToStorage() {
                // æ³¨æ„ï¼šä¸èƒ½ç›´æ¥å­˜å‚¨blobåˆ°localStorageï¼Œè¿™é‡Œåªæ˜¯æ¼”ç¤º
                // å®é™…é¡¹ç›®ä¸­éœ€è¦å°†éŸ³é¢‘ä¸Šä¼ åˆ°æœåŠ¡å™¨
                const storageData = this.recordings.map(r => ({
                    id: r.id,
                    duration: r.duration,
                    timestamp: r.timestamp,
                    size: r.size
                }));
                localStorage.setItem('recordings', JSON.stringify(storageData));
            }
        }

        // åˆå§‹åŒ–å½•éŸ³ç®¡ç†å™¨
        const recordingManager = new RecordingManager();
    </script>
</body>

</html>